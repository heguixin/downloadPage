<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <style>
        .el-row {
            margin-bottom: 10px;
        }

        .el-col {
            border-radius: 4px;
        }

        .bg-purple-dark {
            background: #99a9bf;
        }

        .bg-purple {
            background: #d3dce6;
        }

        .bg-purple-light {
            background: #e5e9f2;
        }

        .grid-content {
            border-radius: 4px;
            min-height: 36px;
        }

        .row-bg {
            padding: 10px 0;
            background-color: #f9fafc;
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- 下载信息详情 -->
        <div v-show="downloadInforVisible">
            <el-row>
                <el-col :span="24">
                    <div class="grid-content bg-purple-dark">
                        <span>文件夹大小：{{ unitConversion(downloadCategorySize) }}</span>
                    </div>
                </el-col>
            </el-row>
            <el-row :gutter="20">
                <el-col :span="8">
                    <div class="grid-content bg-purple">
                        <span>
                            已下载文件进度：{{ downloadOriginFileCount - downloadFileCount }} / {{ downloadOriginFileCount }}
                        </span>
                    </div>
                </el-col>
                <el-col :span="8">
                    <div class="grid-content bg-purple">
                        <span>等待&正在下载文件数量：{{ downloadFileCount }}</span>
                    </div>
                </el-col>
                <el-col :span="8">
                    <div class="grid-content bg-purple">
                        <span>下载文件异常数量：{{ downloadedErrorRecordData.length }}</span>
                    </div>
                </el-col>
            </el-row>
            <el-row>
                <el-col :span="24">
                    <div class="grid-content bg-purple-dark">
                        <span>请不要关闭标签页，否则会暂停下载流程</span>
                    </div>
                </el-col>
            </el-row>
        </div>

        <!-- 下载进度详情 -->
        <el-steps :active="downloadCategoryStep" simple>
            <el-step title="点击选择种子" icon="el-icon-orange" @click.native="onDownloadCategoryAndMaterialFS"></el-step>
            <el-step title="选择导出目录" icon="el-icon-folder"></el-step>
            <el-step title="构建目录" icon="el-icon-folder-opened"></el-step>
            <el-step title="下载文件" icon="el-icon-document-copy"></el-step>
            <el-step title="结束" icon="el-icon-s-cooperation"></el-step>
        </el-steps>

        <el-progress :text-inside="true" :stroke-width="26" :percentage="downloadProgress"></el-progress>

        <!-- 下载记录详情 -->
        <el-table :data="downloadRecordData" style="width: 100%" height="500" stripe>
            <el-table-column prop="date" label="时间" width="150"></el-table-column>
            <el-table-column prop="size" label="大小" width="100"></el-table-column>
            <el-table-column prop="filePath" label="下载内容"></el-table-column>
            <el-table-column label="下载进度">
                <template slot-scope="scope">
                    <el-progress :text-inside="true" :stroke-width="20"
                        :percentage="downloadRecordData[scope.$index].progress">
                    </el-progress>
                </template>
            </el-table-column>
        </el-table>

        <!-- 下载错误记录详情 -->
        <div v-show="downloadedErrorRecordData.length > 0">
            <el-row>
                <el-col :span="24">
                    <div class="grid-content bg-purple-dark"><span>下载异常文件记录</span></div>
                </el-col>
            </el-row>
            <el-table :data="downloadedErrorRecordData" style="width: 100%" height="500" stripe>
                <el-table-column prop="date" label="时间" width="100"></el-table-column>
                <el-table-column prop="status" label="状态码" width="100"></el-table-column>
                <el-table-column prop="statusText" label="状态" width="120"></el-table-column>
                <el-table-column prop="size" label="大小" width="100"></el-table-column>
                <el-table-column prop="filePath" label="下载内容" width="150"></el-table-column>
                <el-table-column prop="url" label="下载链接"></el-table-column>
            </el-table>
        </div>
    </div>
</body>
<!-- 依赖三个库文件 -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.7.8/dist/vue.js"></script>
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.3/theme-chalk/index.min.css">
<script src="https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.3/index.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

<script>
    new Vue({
        el: '#app',
        data: {
            // 设置模块
            USEPASSWORD: true,
            USEHTTPS: true,
            WRITEHANDLELIMIT: 6,
            // 通用模块
            downloadedFileSize: 0,
            downloadCategorySize: 0,
            downloadOriginFileCount: 0,
            downloadFileCount: 0,
            downloadErrorFileSet: new Set(),
            downloadInforVisible: false,
            writeHandleNum: 0,

            // 下载显示模块
            downloadCategoryStep: 0,
            downloadStartTimestamp: 0,
            downloadProgress: 0,
            downloadRecordData: [],
            downloadedErrorRecordData: [],

            // 下载信息模块
            dirDict: [],
            dirPathDict: { 0: '' },
            fileList: [],
            dirHandleDict: {},
        },

        mounted() {
        },

        watch: {
            downloadFileCount(newVal, oldVal) {
                if (newVal == 0 && oldVal == 1) {
                    this.downloadCategoryStep++
                    this.closeDownloadDialog()
                }
            }
        },

        methods: {
            // 通用函数
            async sleep(time = 1000) {
                return new Promise(resolve => {
                    setTimeout(resolve, time);
                });
            },

            getClock() {
                let date = new Date();
                let h = date.getHours();
                h = h < 10 ? "0" + h : h;
                let m = date.getMinutes();
                m = m < 10 ? "0" + m : m;
                let s = date.getSeconds();
                s = s < 10 ? "0" + s : s;
                return h + ":" + m + ":" + s;
            },

            unitConversion(val) {
                // 特殊处理：用Infinity来代表该文件的大小未知，未知可能是因为资源服务器并不告诉前端资源的大小
                if (val == Infinity) {
                    return "未知大小"
                }

                if (val > 1073741824) {
                    return (val / 1073741824).toFixed(2) + "GB"
                } else if (val > 1048576) {
                    return (val / 1048576).toFixed(1) + "MB"
                } else if (val > 1024) {
                    return (val / 1024).toFixed(0) + "KB"
                } else {
                    return val + "B"
                }
            },

            formatProgress(percentage) {
                return percentage > 100 ? 100 : percentage;
            },

            // 把名字转变为一个合乎规范文件系统的名字
            formatName(name, prePath) {
                let that = this
                // 已知以下字符是合乎规范的
                // 英文字符：!@#$%^&()[]{}+-.,
                // 中文字符：～！¥（）「」：｜《》？，。

                // 已知以下字符是不合乎规范的
                // 英文字符：~*:<>?|
                let illegalCharList = name.match(/[~*:<>?|]/g)
                if (illegalCharList != null) {
                    let warningMessage =
                        '<p>修改前目录名:' + name + '</p>' +
                        '<p>非法字符列表（转为-）[' + illegalCharList.join(',') + ']</p>' +
                        '<p>非法字符个数:' + illegalCharList.length + '</p>' +
                        '<p>修改后目录路径:' + prePath + name.replace(/[~*:<>?|]/g, '-') + '/' + '</p>'

                    that.$notify.warning({
                        title: '以下目录的名字已经修改',
                        message: warningMessage,
                        duration: 0,
                        dangerouslyUseHTMLString: true,
                    })
                }
                return name.replace(/[~*:<>?|]/g, '-')
            },

            formatUrl(url) {
                return this.USEHTTPS ? url.replace("http://", "https://") : url
            },

            async getFileDownloadProgress(stream, recordData, fileSize) {
                let that = this
                let total = 0;
                const reader = stream.getReader();
                const read = () => reader.read().then(({ value, done }) => {
                    if (done) {
                        recordData.progress = 100
                        return
                    }
                    total += value.length;
                    // headers有可能不告知大小，然后让progress超过100的进度引发错误，所以最高进度设置为100防止抛出错误
                    let now_progress = parseFloat((total / fileSize * 100).toFixed(2))
                    recordData.progress = that.formatProgress(now_progress)
                    read();
                });
                read();
            },

            AES_ECB_DECRYPT(textBase64, secretKey) {
                var keyHex = CryptoJS.enc.Base64.parse(secretKey);
                var decrypt = CryptoJS.AES.decrypt(textBase64, keyHex, {
                    "mode": CryptoJS.mode.ECB,
                    "padding": CryptoJS.pad.Pkcs7
                });
                return CryptoJS.enc.Utf8.stringify(decrypt);
            },

            // 下载文件夹
            onDownloadCategoryAndMaterialFS() {
                let that = this
                if (that.downloadCategoryStep == 3 || that.downloadCategoryStep == 4) {
                    return
                }
                that.initDownloadDialog()

                that.parseSeedInfor()
                    .then(() => {
                        that.downloadInforVisible = true
                        let tipText = '<p>压缩包大小预估:' + that.unitConversion(that.downloadCategorySize) + '</p>' +
                            '<p>文件个数:' + that.downloadFileCount + '</p>' +
                            '<br/>' +
                            '<p><strong>下载开始后，不可关闭当前页面，否则将会中断下载任务！<strong></p>' +
                            '<p>尽可能下载所有文件，异常文件会打印错误记录，截图联系管理员!</p>'

                        that.$alert(tipText, '下载确认',
                            {
                                confirmButtonText: '确定',
                                dangerouslyUseHTMLString: true,
                                callback: action => {
                                    if (action === 'confirm') {
                                        that.downloadCategoryStep++
                                        that.downloadCategoryAndMaterialFS()
                                    }
                                }
                            }
                        )
                    })
                    .catch(error => {
                        that.$notify.warning({ title: '取消', message: error })
                    })
            },

            downloadCategoryAndMaterialFS() {
                let that = this

                that.downloadCategory()
                    .then(() => {
                        that.downloadStartTimestamp = Date.parse(new Date()) / 1000
                        that.downloadFile()
                    })
                    .catch(error => {
                        that.$notify.warning({ title: '取消', message: error })
                    })
            },

            initDownloadDialog() {
                let that = this
                // 通用模块
                that.downloadedFileSize = 0
                that.downloadCategorySize = 0
                that.downloadFileCount = 0
                that.downloadErrorFileSet = new Set()
                that.downloadInforVisible = false
                that.writeHandleNum = 0

                // 下载显示模块
                that.downloadCategoryStep = 0
                that.downloadProgress = 0
                that.downloadRecordData = []
                that.downloadedErrorRecordData = []

                // 下载信息模块
                that.dirHandleDict = {}
                that.dirPathDict = { 0: '' }
            },

            // 下载记录相关
            async closeDownloadDialog() {
                let that = this
                let end = Date.parse(new Date()) / 1000

                // 打印错误的统计信息
                if (that.downloadErrorFileSet.size > 0) {
                    let warningMessage = ''
                    for (let filePath of that.downloadErrorFileSet) {
                        warningMessage += '<p>文件:' + filePath + '</p>'
                    }
                    warningMessage += '<p>共计:' + that.downloadErrorFileSet.size + '(个)</p>'

                    that.$notify.warning({
                        title: '文件异常列表统计(无下载)',
                        message: warningMessage,
                        duration: 0,
                        dangerouslyUseHTMLString: true,
                    })
                }

                // 打印下载结果，允许关闭页面
                await that.sleep(1000)
                that.downloadCategoryStep++
                that.downloadProgress = 100
                that.$notify.success({
                    title: '完成',
                    message: '耗时(s):' + (end - that.downloadStartTimestamp),
                    duration: 0
                })
            },

            pushDownloadProgress(fileSize) {
                let that = this
                let now_progress = 0

                that.downloadFileCount -= 1
                // 如果是未知目录大小，总进度条就按照文件个数推进
                // 如果是已知目录大小，总进度条就按照目录大小推进
                if (that.downloadCategorySize == Infinity) {
                    now_progress = parseFloat(((that.downloadOriginFileCount - that.downloadFileCount) / that.downloadOriginFileCount * 100).toFixed(2))
                    // 防止进度条溢出
                    that.downloadProgress = that.formatProgress(now_progress)
                } else {
                    that.downloadedFileSize += fileSize == Infinity ? 0 : fileSize
                    now_progress = parseFloat((that.downloadedFileSize / that.downloadCategorySize * 100).toFixed(2))
                    // 防止进度条溢出
                    that.downloadProgress = that.formatProgress(now_progress)
                }
            },

            recordDownloadCategoryData(filePath, fileSize, teeProgress = null) {
                let that = this
                let clock = that.getClock()

                let recordData = { 'date': clock, 'filePath': filePath, 'size': that.unitConversion(fileSize), 'progress': 0 }
                that.downloadRecordData.push(recordData)
                // 已有文件时
                if (teeProgress == null) {
                    recordData.progress = 100
                }
                // 下载文件时
                else {
                    that.getFileDownloadProgress(teeProgress, recordData, fileSize)
                }
            },

            notifyDownloadError(filePath, status, statusText, fileSize, fileUrl) {
                let that = this
                that.downloadErrorFileSet.add(filePath)
                that.downloadedErrorRecordData.push({
                    'date': that.getClock(),
                    'status': status,
                    'statusText': statusText,
                    'size': that.unitConversion(fileSize),
                    'filePath': filePath,
                    'url': fileUrl,
                })

                // 是否需要打印出来异常的文件
                // let errTip = '<p>文件:</p><p>' + filePath + '</p>' +
                //     '<p>状态码:' + status + '</p>' +
                //     '<p>状态信息:' + statusText + '</p>'
                // that.$notify.error({
                //     title: '文件异常',
                //     message: errTip,
                //     duration: 0,
                //     dangerouslyUseHTMLString: true,
                // })
            },

            async parseSeedInfor() {
                let that = this
                let [fileHandle] = await window.showOpenFilePicker()
                let seedDict = {}

                //获取文件
                const file = await fileHandle.getFile()

                if (that.USEPASSWORD) {
                    return that.$prompt('请输入提取码', '提示', {
                        confirmButtonText: '确定',
                        cancelButtonText: '取消',
                        inputPattern: /[0-9a-zA-Z]{43}/,
                        inputErrorMessage: '密码格式不正确'
                    }).then(async ({ value, action }) => {
                        if (action == 'confirm') {
                            //读取文件内容
                            let text = await file.text()
                            // 解密
                            seedDict = JSON.parse(that.AES_ECB_DECRYPT(text, value))
                            that.dirDict = seedDict['dirDict']
                            that.fileList = seedDict['fileList']
                            // 如果是未知目录大小，总进度条就按照文件个数推进
                            // 如果是已知目录大小，总进度条就按照目录大小推进
                            that.downloadCategorySize = seedDict['downloadCategorySize'] == undefined ? Infinity : seedDict['downloadCategorySize']
                            that.downloadFileCount = seedDict['fileList'].length
                            that.downloadOriginFileCount = that.downloadFileCount
                            that.$message({
                                type: 'success',
                                message: '解密成功'
                            });
                        }
                        else {
                            that.$message({
                                type: 'success',
                                message: '取消输入'
                            });
                        }
                    }).catch(() => {
                        throw '密码错误'
                    });
                } else {
                    let text = await file.text()
                    // 解密
                    seedDict = JSON.parse(text)
                    that.dirDict = seedDict['dirDict']
                    that.fileList = seedDict['fileList']
                    // 如果是未知目录大小，总进度条就按照文件个数推进
                    // 如果是已知目录大小，总进度条就按照目录大小推进
                    that.downloadCategorySize = seedDict['downloadCategorySize'] == undefined ? Infinity : seedDict['downloadCategorySize']
                    that.downloadFileCount = seedDict['fileList'].length
                    that.downloadOriginFileCount = that.downloadFileCount
                    that.$message({
                        type: 'success',
                        message: '解密成功'
                    });
                }
            },

            async createCategoryLoop(currentDirHandle, currentDir, preDirPath) {
                let that = this
                let cur_name = that.formatName(currentDir['name'], preDirPath)
                that.dirHandleDict[currentDir['id']] = await currentDirHandle.getDirectoryHandle(cur_name, { create: true })
                that.dirPathDict[currentDir['id']] = preDirPath + cur_name + '/'

                if (currentDir['children'].length > 0) {
                    for (let child_dir of currentDir['children']) {
                        await that.createCategoryLoop(that.dirHandleDict[currentDir['id']], child_dir, that.dirPathDict[currentDir['id']])
                    }
                }
            },

            async downloadCategory() {
                let that = this
                let currentDirHandle = await window.showDirectoryPicker()
                that.downloadCategoryStep++

                for (let dir of that.dirDict["children"]) {
                    await that.createCategoryLoop(currentDirHandle, dir, '')
                }
            },

            async downloadFile() {
                let that = this
                that.downloadCategoryStep++

                for (let file of that.fileList) {
                    // 等待有空闲的写入流
                    while (that.writeHandleNum >= that.WRITEHANDLELIMIT) {
                        await that.sleep()
                    }
                    that.writeHandleNum += 1
                    let fileHandle = await that.dirHandleDict[file['last_category_id']].getFileHandle(file['name'], { create: true });
                    let oldFileHandle = await fileHandle.getFile()
                    that.writeURLToFile(fileHandle, file['url'], that.dirPathDict[file['last_category_id']] + file['name'], file['size'], oldFileHandle.size)
                }
            },

            async writeURLToFile(fileHandle, url, path, size, oldFileSize) {
                let that = this
                url = that.formatUrl(url)
                // 发起fetch请求，获取资源
                const { ok, status, statusText, headers, body } = await fetch(
                    url,
                    {
                        // 禁用下载时利用缓存，任何一个资源都触发单独的下载
                        cache: "no-store"
                    }
                )
                let fileSize = parseInt(headers.get("Content-Length"))

                // 根据大小来判断本地是否已经有同样的文件了，所以能否复用历史文件则要依赖服务器有没有返回长度字段。
                // 情况一：如果本地有了大小完全一样的文件,那么就直接打印信息,不再获取
                // console.log(path, oldFileSize, fileSize, oldFileSize == fileSize)
                if (oldFileSize == fileSize) {
                    // 已有文件则关掉请求资源的流操作
                    body.cancel()
                    that.recordDownloadCategoryData(path + "（本地已有）", fileSize)
                    that.pushDownloadProgress(fileSize)
                    that.writeHandleNum -= 1
                    return
                }
                // 情况二：如果本地已经有文件,但是和服务器的文件大小不一样，那么就更新这个文件
                else if (oldFileSize != fileSize && oldFileSize != 0) {
                    path += "（更新文件）"
                }
                // 情况三：其他情况都视为新下载文件

                const writable = await fileHandle.createWritable()

                // 优先相信报文头部反馈的大小，次之相信种子文件给予的大小，最后用Infinity来代表未知大小
                fileSize = isNaN(fileSize) ? (size == undefined ? Infinity : size) : fileSize

                if (!ok) {
                    that.notifyDownloadError(path, status, statusText, fileSize, url)
                    that.pushDownloadProgress(fileSize)
                    writable.close()
                    that.writeHandleNum -= 1
                    return
                }

                const [teeProgress, teeWrite] = body.tee()

                // 记录每一个文件的下载进度
                that.recordDownloadCategoryData(path, fileSize, teeProgress)

                // 流式保存文件和记录总进度
                // Stream the response into the file.
                await teeWrite.pipeTo(writable).finally(() => {
                    that.pushDownloadProgress(fileSize)
                    that.writeHandleNum -= 1
                });
                // pipeTo() closes the destination pipe by default, no need to close it.
            },

            // 下载文件的工具函数-仅作参考
            async writeFile(fileHandle, contents) {
                // Create a FileSystemWritableFileStream to write to.
                const writable = await fileHandle.createWritable();
                // Write the contents of the file to the stream.
                await writable.write(contents);
                // Close the file and write the contents to disk.
                await writable.close();
            },
        }
    })
    /*
    * File System APi
    * API参考地址：https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker
    */
</script>

</html>